---
name: ExecPlan
description: 複雑な機能実装や大規模リファクタリング時に使用する実行計画（ExecPlan）を作成・維持するスキル。数時間にわたる作業を自律的に進めるためのリビングドキュメント。
---

# ExecPlan（実行計画）スキル

このスキルは、複雑な機能実装やシステム変更において、コーディングエージェントが遵守すべき設計ドキュメント（ExecPlan）の作成と運用方法を定めるものです。

ExecPlanは、このリポジトリを初めて触る人でも、現在のワーキングツリーとExecPlanファイルだけで作業を完遂できるよう設計されています。過去の計画の記憶や外部コンテキストには依存しません。

---

# ExecPlanの使い方

## ExecPlanを作成するとき

PLAN.md（このファイル）の内容に**厳密に従って**ください。コンテキストにない場合は、このファイル全体を読み直してから作業を始めてください。ソース資料を徹底的に読み込み、正確な仕様書を作成してください。仕様作成時は、骨格から始めて調査を進めながら肉付けしていきます。

## ExecPlanを実行するとき

ユーザーに「次のステップは？」と確認を求めず、次のマイルストーンに進んでください。すべてのセクションを最新状態に保ち、作業の区切りごとにリストへエントリを追加または分割して、進捗と次のステップを明示してください。曖昧な点は自律的に解決し、頻繁にコミットしてください。

## ExecPlanを議論・更新するとき

決定事項は計画内のログに記録し、後から参照できるようにしてください。なぜ仕様を変更したのかが明確にわかるようにします。ExecPlanはリビングドキュメントであり、常に**ExecPlanのみから作業を再開**できる状態を維持してください。

## 設計調査時の注意

要件が厳しい場合や不確定要素が多い場合は、マイルストーン内でプロトタイプや「トイ実装」を行い、ユーザーの提案が実現可能かを検証してください。ライブラリのソースコードを取得して読み込み、深く調査し、本実装のガイドとなるプロトタイプを含めてください。

---

# 必須要件

以下は**交渉の余地がない要件**です：

- **完全な自己完結性**: ExecPlanは、その時点で初心者が成功するために必要なすべての知識と手順を含んでいなければならない
- **リビングドキュメント**: 進捗、発見、設計決定があるたびに改訂し、常に自己完結した状態を維持する
- **初心者対応**: このリポジトリを知らない初心者でも、エンドツーエンドで機能を実装できる内容にする
- **動作する成果物**: 単なる「定義を満たすコード変更」ではなく、実証可能な動作を生み出す
- **平易な言葉**: 専門用語を使う場合は、必ず平易な言葉で定義するか、使用しない

---

# 目的とユーザー視点

最初に、なぜこの作業が重要かをユーザー視点で説明してください：
- この変更後に何ができるようになるか
- どうすればそれが動いているのを確認できるか

次に、その成果を達成するための正確な手順を読者に示します：
- 何を編集するか
- 何を実行するか
- 何を観察すべきか

---

# コンテキストの明示

ExecPlanを実行するエージェントは、ファイル一覧、ファイル読み込み、検索、プロジェクト実行、テスト実行が可能です。しかし、**過去のコンテキストは知らず**、以前のマイルストーンから意図を推測することはできません。

依存する前提は繰り返し記述してください。外部のブログやドキュメントを参照せず、必要な知識は計画内に自分の言葉で埋め込んでください。

---

# フォーマット規則

- ExecPlanをMarkdownファイル（.md）としてのみ保存する場合、トリプルバックティックは省略する
- ヘッディングの後は2行の空行を入れる
- `#`、`##`などを正しく使用する
- 順序付き・順序なしリストの構文を正しく使用する

**平易な散文で書く**。リストよりも文章を優先してください。チェックリストは`Progress`セクションでのみ必須です。

---

# 避けるべき失敗パターン

- 未定義の専門用語に依存しない
- 「機能の文字通りの定義」だけを狭く記述して、コンパイルは通るが意味のある動作をしないコードを生まない
- 重要な決定を読者に委ねない
- 曖昧さがある場合は計画内で解決し、その選択理由を説明する
- ユーザーから見える効果は過度に説明し、付随的な実装詳細は控えめに記述する

---

# 検証可能な成果

成果を観察可能な結果で固定してください：
- 実装後にユーザーが何をできるか
- 実行するコマンド
- 期待される出力

**行動として検証可能な形式**で受け入れ基準を記述してください：
- ✅ 良い例: 「サーバー起動後、http://localhost:8080/health にアクセスするとHTTP 200と本文OKが返る」
- ❌ 悪い例: 「HealthCheck構造体を追加した」

---

# リポジトリコンテキストの明示

- ファイルはリポジトリルートからの完全相対パスで記述
- 関数やモジュールは正確に名前を指定
- 新しいファイルの作成場所を明示
- コマンド実行時は作業ディレクトリと正確なコマンドラインを示す
- 環境依存がある場合は前提を記述し、代替案も提示

---

# 冪等性と安全性

- ステップは何度実行しても害やドリフトを起こさないように書く
- 途中で失敗する可能性がある場合は、リトライや適応方法を含める
- マイグレーションや破壊的操作が必要な場合は、バックアップや安全なフォールバックを明記
- テスト可能な加算的変更を優先し、進みながら検証できるようにする

---

# 検証は必須

検証は省略できません。以下を含めてください：
- テスト実行手順
- システム起動手順（該当する場合）
- 何か有用な動作を観察する方法
- 期待される出力とエラーメッセージ
- 成功と失敗を区別する方法

コンパイル以上の効果を証明する方法を示してください：
- 小さなE2Eシナリオ
- CLIの呼び出し
- HTTPリクエスト/レスポンスのトランスクリプト

---

# マイルストーン

マイルストーンは官僚的なものではなく、**物語**です。

作業をマイルストーンに分割する場合、各マイルストーンには以下を含む簡潔な段落を記述してください：
- スコープ
- このマイルストーンの終了時に存在するもの（以前は存在しなかったもの）
- 実行するコマンド
- 期待される受け入れ結果

**ストーリーとして読めるように**: 目標 → 作業 → 結果 → 証明

各マイルストーンは**独立して検証可能**で、全体目標を**段階的に実装**するものでなければなりません。

---

# リビングドキュメントのセクション

ExecPlanには以下のセクションを**必ず含み、維持**してください：

## Progress（進捗）

チェックボックス付きリストで詳細なステップを要約します。すべての作業区切りをここに記録し、タスクが部分的に完了した場合は「完了部分」と「残り部分」に分割してください。

    - [x] (2025-10-01 13:00Z) 完了したステップの例
    - [ ] 未完了のステップの例
    - [ ] 部分的に完了したステップ（完了: X、残り: Y）

タイムスタンプで進捗率を測定してください。

## Surprises & Discoveries（驚きと発見）

実装中に発見した予期しない動作、バグ、最適化、洞察を記録します。

    - 観察: …
      証拠: …

## Decision Log（決定ログ）

計画作業中に下したすべての決定を記録します。

    - 決定: …
      理由: …
      日時/担当者: …

## Outcomes & Retrospective（成果と振り返り）

主要なマイルストーンや完了時に、達成したこと、残っていること、学んだ教訓を要約します。

---

# プロトタイピングと並行実装

大きな変更のリスクを軽減するために、明示的なプロトタイピングマイルストーンを含めることは推奨されます。

例：
- 依存関係に低レベルオペレーターを追加して実現可能性を検証
- オプティマイザーの効果を測定しながら2つの構成順序を探索

プロトタイプは加算的でテスト可能にしてください。スコープを「プロトタイピング」と明示し、実行方法と結果の観察方法を記述し、プロトタイプを昇格または破棄する基準を明記してください。

---

# ExecPlanのスケルトン

    # <短く行動指向の説明>

    このExecPlanはリビングドキュメントです。`Progress`、`Surprises & Discoveries`、`Decision Log`、`Outcomes & Retrospective`のセクションは作業の進行に合わせて更新し続けなければなりません。

    ## Purpose / Big Picture（目的 / 全体像）

    この変更後に何ができるようになり、どうすれば動作を確認できるかを数文で説明します。実現するユーザーから見える動作を記述します。

    ## Progress（進捗）

    チェックボックス付きリストで詳細なステップを要約します。

    - [x] (2025-10-01 13:00Z) 完了したステップの例
    - [ ] 未完了のステップの例

    ## Surprises & Discoveries（驚きと発見）

    実装中に発見した予期しない動作、バグ、最適化、洞察を記録します。

    - 観察: …
      証拠: …

    ## Decision Log（決定ログ）

    計画作業中に下したすべての決定を記録します。

    - 決定: …
      理由: …
      日時/担当者: …

    ## Outcomes & Retrospective（成果と振り返り）

    主要なマイルストーンや完了時に成果、ギャップ、学んだ教訓を要約します。

    ## Context and Orientation（コンテキストと方向付け）

    読者がこのリポジトリを全く知らないものとして、このタスクに関連する現在の状態を説明します。キーとなるファイルやモジュールを完全パスで命名し、使用する非自明な用語を定義します。

    ## Plan of Work（作業計画）

    編集と追加の順序を散文で説明します。各編集について、ファイル名と場所（関数、モジュール）、挿入または変更する内容を記述します。

    ## Concrete Steps（具体的な手順）

    実行する正確なコマンドとその作業ディレクトリを記述します。コマンドが出力を生成する場合は、読者が比較できるよう短い期待トランスクリプトを示します。

    ## Validation and Acceptance（検証と受け入れ）

    システムの起動または動作確認方法と、観察すべき内容を説明します。受け入れは特定の入力と出力を伴う動作として表現します。

    ## Idempotence and Recovery（冪等性と復旧）

    ステップを繰り返し安全に実行できる場合はその旨を記述。リスクのあるステップには安全なリトライまたはロールバック方法を提示します。

    ## Artifacts and Notes（成果物とメモ）

    最も重要なトランスクリプト、差分、スニペットをインデントした例として含めます。成功を証明するものに焦点を当て、簡潔にしてください。

    ## Interfaces and Dependencies（インターフェースと依存関係）

    使用するライブラリ、モジュール、サービスとその理由を明記します。マイルストーン終了時に存在すべき型、トレイト/インターフェース、関数シグネチャを指定します。

---

# 最終確認

上記のガイダンスに従えば、単一のステートレスなエージェント、または人間の初心者が、ExecPlanを上から下まで読んで、動作する観察可能な結果を生み出すことができます。

これが基準です：**自己完結、自給自足、初心者ガイド、成果重視**

計画を改訂する際は、変更がすべてのセクション（リビングドキュメントセクションを含む）に包括的に反映されていることを確認し、計画の最下部に変更内容と理由を記述するメモを書いてください。
